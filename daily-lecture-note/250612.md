- 스코프 (Scope)
  자바스크립트에서 스코프는 변수나 함수에 접근할 수 있는 '유효 범위'를 의미한다. 코드의 특정 부분이 어디까지 보이고 사용될 수 있는지를 결정한다.

  - 전역 스코프 (Global Scope): 코드의 가장 바깥 영역. 여기서 선언된 변수는 코드 어디에서나 접근할 수 있다.
  - 함수 스코프 (Function Scope): 함수에 의해 생성되는 영역. var 키워드는 이 함수 스코프를 따른다. 함수 내에서 선언된 변수는 함수 안에서만 유효하다.
  - 블록 스코프 (Block Scope): 중괄호 {}로 둘러싸인 영역 (예: if, for, 또는 그냥 {}). let과 const 키워드는 이 블록 스코프를 따른다.
  - 모듈 스코프 (Module Scope): <script type="module"> 을 사용하면 해당 파일은 자신만의 독립적인 스코프를 가진다. 파일 안의 코드는 전역 스코프를 오염시키지 않는다.

- 스코프 체인 (Scope Chain)
  자바스크립트 엔진은 변수를 찾을 때, 현재 스코프에서 먼저 찾아본다.
  만약 현재 스코프에 변수가 없으면, 바로 바깥쪽(상위) 스코프로 이동하여 다시 찾아본다.
  이 과정은 전역 스코프에 도달할 때까지 계속된다.
  만약 전역 스코프에서도 변수를 찾지 못하면 ReferenceError (참조 오류)가 발생한다.

- var vs. let/const
  var: 함수 스코프를 따르며, 블록 스코프를 무시한다. 이 때문에 블록 안에서 선언해도 블록 밖에서 접근이 가능해 예기치 않은 문제를 일으킬 수 있다. 또한 같은 이름으로 여러 번 재선언이 가능하다.
  let, const: 블록 스코프를 따른다. 변수가 선언된 블록 {} 안에서만 유효하며, 같은 이름으로 재선언이 불가능해 훨씬 더 안전하고 예측 가능한 코드를 작성하게 해준다. 따라서 현대 자바스크립트에서는 var의 사용을 지양하고 let과 const 사용을 권장한다.

- 객체 (Object)
  객체는 여러 데이터를 하나의 단위로 묶어 관리하기 위한 자료 구조로, '키(key)'와 '값(value)'의 쌍으로 이루어져 있다.

- 객체 생성: 리터럴 vs. 생성자

  - 객체 리터럴 (Object Literal): const obj = { key: 'value' };
    중괄호 {}를 사용해 만드는 가장 간단하고 직관적인 방법.
    코드가 짧고 가독성이 높아 개발자들이 압도적으로 선호하는 방식이다. **"리터럴이 편하다"**는 말은 이 방식을 의미한다.

  - 생성자 함수 (Constructor Function): const obj = new Object();
    new 키워드와 함께 사용하는 방식으로, 코드가 더 길고 덜 직관적이다.
    자바스크립트 엔진이 내부적으로 객체를 만들 때 사용하는 원리에 가깝다. 개발자는 편리한 리터럴 방식을 쓰면 된다.

- 객체 속성(Property) 다루기
  개체속성은 객체 안의 키와 값으로 이루어진 한쌍의 데이터.
  읽기 (Read):

  - 점 표기법 (Dot Notation): object.key
    가장 일반적이고 간편한 방법.

  - 대괄호 표기법 (Bracket Notation): object['key-string']
    키 이름에 띄어쓰기나 하이픈(-) 같은 특수문자가 포함될 때 사용.
    키 이름을 변수에 담아 동적으로 접근해야 할 때 매우 유용하다.

- 쓰기 및 수정 (Write & Update):

  object.key = 'newValue'; 와 같이 할당 연산자를 사용해 새로운 속성을 추가하거나 기존 속성의 값을 수정할 수 있다.
  삭제 (Delete):

  delete object.key; 와 같이 delete 키워드를 사용해 특정 속성을 삭제할 수 있다.

- 메서드 (Method)
  객체의 여러 속성 중, 그 값이 '함수'인 속성을 특별히 메서드라고 부른다.
  메서드는 그 객체가 할 수 있는 동작이나 기능을 정의한다.

  JavaScript
  const user = {
  name: '형민',
  // greet은 user 객체의 메서드
  greet: function() {
  console.log(`안녕하세요, ${this.name}입니다.`);
  }
  };
  user.greet(); // "안녕하세요, 형민입니다." 출력

- 함수는 객체다 (Functions are Objects)
  자바스크립트의 가장 중요한 특징 중 하나로, 함수도 사실은 특별한 종류의 객체다.
  객체처럼 속성을 가질 수 있다 (myFunc.myProperty = 'value';).
  이 특징 때문에 함수를 일반 값처럼 자유롭게 다룰 수 있다.

- 일급 함수 (First-Class Function)
  "함수는 값이다"라는 개념을 멋지게 표현한 용어. 아래의 조건들을 만족한다는 뜻이다.
  변수에 할당할 수 있다. (const a = myFunction;)
  다른 함수의 인수로 전달할 수 있다. (anotherFunction(myFunction);)
  다른 함수에서 반환될 수 있다. (return myFunction;)

- 고차 함수 (Higher-Order Function)
  위의 '일급 함수' 특징을 활용하는 함수를 말한다.
  다른 함수를 인수로 받거나, 또는 함수를 결과로 반환하는 함수를 고차 함수라고 부른다.
  결론: '일급 함수', '고차 함수' 같은 용어들이 어렵게 느껴질 수 있지만, 핵심은 "자바스크립트의 함수는 숫자나 문자열처럼 변수에 담고, 주고받을 수 있는 값(value)이다" 라는 한 문장으로 요약된다.

- 객체 비교: "내용이 같아도 다르다"

  눈으로 보기에 내용이 완전히 똑같은 두 객체를 === (엄격한 비교) 또는 == (느슨한 비교)로 비교하면, 결과는 항상 false (거짓)가 나온다.
  값(Value)이 아닌 참조(Reference)로 비교하기 때문

  원시 타입(숫자, 문자 등): let a = 10; let b = 10; 처럼 값을 직접 비교한다. 따라서 a === b는 true다.
  객체 타입(객체, 배열, 함수): 객체를 생성하면, 그 객체는 컴퓨터 메모리의 특정 공간에 저장되고, 고유한 **'메모리 주소(신분증)'**를 부여받는다. 변수에는 객체의 내용이 아니라 이 '메모리 주소'가 저장된다.
  따라서 두 객체를 비교하는 것은 **"두 객체의 내용이 같은가?"**를 묻는 게 아니라 **"두 객체가 같은 메모리 주소를 가리키고 있는가?"**를 묻는 것이다. 리터럴 {}로 각각 생성한 두 객체는 내용이 똑같아도 서로 다른 '신분증'을 가지므로 다른 객체로 취급된다.

  JavaScript

  const user1 = { name: '형민' };
  const user2 = user1; // user1의 '메모리 주소'를 user2에 복사

  console.log(user1 === user2); // true
  위 코드에서 user2는 새로운 객체를 만든 게 아니라, user1이 가리키는 메모리 주소(참조)를 그대로 복사해 왔다. 이제 두 변수는 동일한 하나의 객체를 가리키므로, 비교 결과는 true가 된다. 이 상태에서 user2.name = '민형'으로 바꾸면 user1.name도 똑같이 바뀐다.

- 조건문 (if, else if, else)

  - 프로그램의 실행 흐름을 특정 조건에 따라 제어하는 구문이다.

  기본 구조:

  JavaScript

  if (조건1) {
  // 조건1이 참(Truthy)일 때 실행
  } else if (조건2) {
  // 조건1은 거짓이고, 조건2가 참(Truthy)일 때 실행
  } else {
  // 위의 모든 조건이 거짓일 때 실행
  }
  참 같은 값(Truthy) vs. 거짓 같은 값(Falsy):
  if 문의 조건식은 true/false로 평가된다. 자바스크립트에서 **Falsy(거짓 같은 값)**로 취급되는 6가지만 기억하면 된다.

  Falsy 값 6가지: false, 0, "" (빈 문자열), null, undefined, NaN

  이 6가지를 제외한 모든 값(예: [], {})은 **Truthy(참 같은 값)**로 평가된다.

- 비교 연산자: == vs. ===

  == (느슨한 동등 비교): 타입을 자동으로 변환해서 비교한다. ('10' == 10 → true) 예기치 않은 결과를 낳을 수 있어 사용을 권장하지 않는다.
  === (엄격한 동치 비교): 타입과 값을 모두 비교한다. ('10' === 10 → false) 훨씬 더 안전하고 명확하므로 항상 ===를 사용하는 습관을 들이는 것이 좋다.

- 여러 조건 결합하기 (&&, ||):
  && (AND): 두 조건이 모두 참이어야 전체가 참이 된다. (신호등 === '노란불') && (자동차가 === '멈춤')
  || (OR): 두 조건 중 하나라도 참이면 전체가 참이 된다. (신호등 === '빨간불') || (신호등 === '노란불')
  한 줄 요약:
  객체는 내용이 아닌 **메모리 주소(참조)**로 비교하며, 조건문에서는 **엄격한 비교(===)**를 사용하고 6가지 Falsy 값을 기준으로 로직을 짜는 것이 중요하다.
