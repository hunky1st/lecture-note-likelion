## 1-3교시

- 매개변수(Parameter)와 인수(Argument)

  매개변수: 함수를 선언할 때 괄호 안에 정의하는 변수. let, const 같은 키워드 없이 이름만으로 선언한다.
  인수: 함수를 호출할 때 전달하는 실제 값. 전달된 인수는 순서에 맞게 매개변수에 할당된다.

- 스코프 (Scope, 유효 범위)

  전역 (Global): 코드 전체 영역. 전역에 선언된 변수는 어디서든 접근 가능하다.
  지역 (Local): 함수 내부의 영역. 함수 내에서 선언된 변수(지역 변수)나 매개변수는 그 함수 안에서만 접근할 수 있다.
  함수 외부에서 지역 변수나 매개변수에 접근하려고 하면 ReferenceError (참조 오류)가 발생한다.

- 변수와 매개변수의 이름 충돌

  하나의 함수 내에서 매개변수와 지역 변수의 이름은 같을 수 없다. 이름이 중복되면 SyntaxError (문법 오류)가 발생한다.

- 함수의 값 반환 (return)

  함수가 계산하거나 처리한 결과를 외부로 내보내려면 반드시 return 키워드를 사용해야 한다.
  return이 없는 함수는 내부에서 코드를 실행할 뿐, 최종 결과값을 외부에 반환하지 않는다.
  return 없이 함수를 호출하고 그 결과를 변수에 담으면, 그 변수에는 undefined가 할당된다.

- console.log와 return의 차이

  console.log(): 개발자 도구의 콘솔에 값을 출력하는 기능일 뿐, 함수가 값을 반환하는 것과는 관련이 없다. 디버깅 용도로 사용된다.
  return: 함수가 실행된 후 최종적으로 가지게 될 값을 지정한다. 이 반환된 값은 다른 변수에 할당하거나 다른 함수의 인수로 사용할 수 있다.

- 암묵적 반환 (Implicit Return)

  함수에 return 문을 명시적으로 작성하지 않으면, 함수는 기본적으로 undefined를 암묵적으로 반환한다. 즉 **모든** 함수는 어떤 값이든 반드시 반환한다.

- 매개변수 기본값
  함수 호출 시 인수를 전달하지 않으면, 해당 인수에 매칭되는 매개변수는 undefined 값을 갖는다.
  변수를 선언만 하고 값을 할당하지 않았을 때 undefined가 되는 것과 동일하다.

- 함수 표현식과 호이스팅 (Hoisting)

  - 표현식 (Expression)

  값으로 평가될 수 있는 모든 코드를 의미한다. 10 + 20 같은 계산식이나, 값을 반환하는 함수 호출 등이 모두 표현식이다.
  자바스크립트에서는 표현식이 먼저 계산되어 값으로 바뀐 후에 다른 작업이 처리된다.

  - 호이스팅 (Hoisting)

  코드가 실행되기 전, 자바스크립트 엔진이 함수나 변수의 '선언부'를 해당 스코프의 최상단으로 끌어올린 것처럼 동작하는 현상을 말한다. (실제로 코드가 이동하는 것은 아니지만, 그렇게 보이는 현상)

- 함수 선언문의 호이스팅

  function 이름() {} 형태로 선언된 함수는 통째로 호이스팅된다.
  따라서 코드상에서 함수를 선언한 위치보다 앞에서 함수를 호출해도 정상적으로 작동한다.
  이를 활용하면 파일 상단에 코드의 주요 실행 흐름을 먼저 작성하고, 세부 함수 정의는 하단에 모아두는 방식으로 코드 가독성을 높일 수 있다.

- 변수 선언의 호이스팅

  var: 선언부(var 이름;)만 호이스팅된다. 값 할당 부분은 원래 자리에 남아있다. 따라서 변수 선언 전에 접근하면 에러는 나지 않지만 undefined가 출력된다.
  let, const: 선언부만 호이스팅되지만, **시간상 사각지대 (Temporal Dead Zone, TDZ)**라는 개념이 적용된다. 스코프에 진입한 후 변수 선언 라인에 도달하기 전까지 해당 변수에 접근할 수 없다. 만약 접근을 시도하면 ReferenceError가 발생한다. 이는 코드의 예측 가능성을 높여주므로 var보다 let과 const의 사용이 권장된다.

- 함수를 만드는 두 가지 방법

  - 함수 선언문 (Function Declaration)

  function myFunction() { ... }
  호이스팅의 영향을 받는다.

  - 함수 표현식 (Function Expression)

  자바스크립트에서는 함수를 값으로 취급하므로, 변수에 할당할 수 있다.
  const myFunction = function() { ... };
  이때 할당되는 함수는 이름이 없는 **익명 함수(Anonymous Function)**일 수 있다.
  변수 선언 규칙(let, const)을 따르므로, 선언 전에 호출하면 TDZ의 영향으로 ReferenceError가 발생한다.

## 4~7교시

- 함수 선언문 vs. 함수 표현식과 호이스팅
  함수를 만드는 두 가지 방식인 함수 선언문과 함수 표현식은 호이스팅(Hoisting) 동작에서 중요한 차이를 보인다.

  - 함수 선언문 (function name() {})
    함수 전체가 호이스팅 되므로, 코드상 선언 위치보다 앞에서 호출해도 정상적으로 동작한다.

  - 함수 표현식 (const name = function() {})
    변수 선언 규칙을 따른다.
    let 또는 const로 선언 시: 변수가 **TDZ(시간상 사각지대)**에 놓이므로 선언 전에 호출하면 ReferenceError가 발생한다.
    var로 선언 시: 변수 선언만 호이스팅 되어 undefined 상태가 된다. 이 상태에서 함수로 호출하면 TypeError (함수가 아니라는 오류)가 발생한다.

  결론적으로 함수 표현식은 호이스팅 현상을 활용할 수 없으므로, 반드시 선언된 이후에 호출해야 한다.

- const를 사용하는 이유

  함수 표현식에서는 let보다 const 사용이 권장된다.
  let은 재할당이 가능하므로, 코드 중간에 다른 값(객체, 숫자 등)이 의도치 않게 할당되어 함수가 사라질 위험이 있다.
  const는 재할당을 막아주므로, 함수가 다른 값으로 변경되는 것을 방지하여 코드의 안정성을 높인다.

- 화살표 함수 표현식 (Arrow Function Expression)
  ES6(2015)에서 도입된, 함수를 더 간결하게 작성할 수 있는 문법이다.
  function 키워드를 생략하고, 매개변수와 함수 본문 사이에 "뚱뚱한 화살표(=>)"를 사용한다.

  JavaScript

  // 일반 함수 표현식
  const add_normal = function(x, y) {
  return x + y;
  };

  // 화살표 함수 표현식
  const add_arrow = (x, y) => {
  return x + y;
  };
  화살표 함수는 함수 표현식의 일종이므로, 호이스팅되지 않는다.

  화살표 함수의 다양한 구문
  화살표 함수는 매개변수의 개수와 본문(body)의 형태에 따라 더 간결하게 변형될 수 있다.

- 매개변수 (Parameters)

  - 1개일 때: 소괄호 ()를 생략할 수 있다.
    JavaScript
    const double = x => { return x \* 2; };

  - 0개 또는 2개 이상일 때: 소괄호 ()를 반드시 써야 한다.
    JavaScript
    const sayHello = () => { console.log('Hello'); };
    const add = (x, y) => { return x + y; };
    (관례) 매개변수가 없거나 사용하지 않을 때, () 대신 밑줄 \_을 사용하기도 한다.

- 암묵적 반환 (Implicit Return)

  함수 본문이 return 한 줄로만 이루어져 있다면, 중괄호 {}와 return 키워드를 동시에 생략할 수 있다. 이 경우 표현식의 결과가 자동으로 반환(return)된다.
  JavaScript

  // 명시적 반환
  const double = x => { return x \* 2; };

  // 암묵적 반환 (위와 동일하게 동작)
  const double = x => x \* 2;
  객체(Object)를 암묵적으로 반환할 때

- 객체 리터럴 {}는 함수 본문의 중괄호 {}와 모양이 같아 혼동을 일으킨다.
  엔진이 함수 본문으로 오해하는 것을 막기 위해, 반환할 객체를 소괄호 ()로 감싸주어야 한다.
  JavaScript

  // 잘못된 예시: 문법 오류 발생
  // const getUser = () => { name: '형민', age: 20 };

  // 올바른 예시: 객체를 소괄호로 감싸서 값(표현식)임을 명시
  const getUser = () => ({ name: '형민', age: 20 });

- 함수 선언문: 재사용될 가능성이 높은 일반적인 함수를 처음 정의할 때 사용.
- 화살표 함수: 다른 함수의 인수로 전달되는 익명 함수(콜백 함수) 등, 일회성으로 사용되거나 간결함이 필요할 때 유용.
  실습 함수 로직 핵심
- 짝수/홀수 판별: 나머지 연산자 %를 사용한다. 숫자 % 2의 결과가 0이면 짝수, 1이면 홀수다.

- 비교 연산자:
  - == 또는 ===: 두 값이 같은지 비교.
  - > : 왼쪽 값이 더 큰지 비교.
  - > =: 왼쪽 값이 크거나 같은지 비교.
  - 이러한 비교의 결과는 true 또는 false (불리언 값)로 나온다.
  - 퍼센트 계산: (부분값 / 전체값) \* 100
